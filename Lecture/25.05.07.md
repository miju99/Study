## 오늘의 주제
* 디자인 패턴

디자인 패턴이란?
- 반복적으로 등장하는 문제에 대한 해결 방법을 정형화시킨 것.
- 개발자들이 계속 반복되는 이슈를 공유가능한 형식으로 정리하고 네이밍을 붙인 것.

사용 이유
- 효율적이고 구조적인 개발을 하기 위해
- 유지보수성과 확장성을 고려하기 위해
- 협업과 코드 재사용을 통한 생산성을 향상시킬 수 있음

사용 시 경계해야 할 것들
- 과유 불급!
  - 모든 곳에 억지로 패턴을 적용하면 안 된다. -> 디자인 패턴만을 위한 개발이 되지 않도록 주의!
- 내 코드에 자신이 취하지 말자!
  - 팀원이 이해하지 못하는 코드는 오히려 개발 속도를 떨어지게 한다.

- 제대로 알고 제대로 쓰기
  - 디자인 패턴은 도구입니다. 목적에 맞게 잘 사용해야 하며, 팀과 함께 균형있게 적용해야 한다.

- 알아두면 좋은 디자인 패턴 우선 순위
  1. 싱글턴 패턴 - 전역 상태 관리, 게임 매니저 등에서 유용하게 사용, 어느 스크립트든 다이렉트로 바로 사용 가능! 모든 것들 싱글톤으로 사용하지 않도록 주의!  가용 메모리가 줄어들고 디버깅 시 어려움을 겪을 수 있음.
  2. 옵저버 패턴 - 이벤트 시스템, UI 업데이트 등에서 활용, ex)델리게이트 사용 | health bar 바뀔 때 | 한쪽에서 참조를 하고 있는 형태
  3. 전략 패턴 (Strategy Pattern) - 무기 시스템, NPC AI 등에서 동작을 런타임에 변경할 때 유용 |무기 캡슐화 사용, NPC 나 플레이어 동작을 런타임에서 바꿀 수 있음
  4. 상태 패턴 (state Pattern) - 캐릭터 상태 관리, 게임 상태 전환 등에서 사용
  5. 팩토리 패턴 - 객체 생성 로직 분리, 다양한 타입의 적 또는 아이템 생성에 유용 | 공장에서 기성품을 만든 것을 사오듯이 객체를 공장에서 만들고 필요한 enermy를 하나씩 가져와서 사용하는 방식
  6. 오브젝트 풀링 - 메모리 관리와 성능 최적화에 유용, 적이나 총알 등 재사용 가능한 오브젝트 관리 | 발사체와 같은 오브젝트는 무조건 사용해주어야 한다. Destroy는 부하가 많이 걸림
  7. 중재자 패턴 (Mediator Pattern) - 옵저버 패턴과 유사. 디커플링을 윟 ㅐ만들어짐. UI 요소[이벤트 발생] -> 이벤트채널(이벤트 버스) [이벤트가 변경되었다고 알려줌] -> 이벤트 리스터, 복잡한 객체 간의 의존성 감소 | 중간의 매개체(이벤트채널, 이벤트 버스 클래스)만 서로를 알고 있고, UI요소와 이벤트 리스너는 서로를 모름.
옵저버는 느슨한 결합(커플링), 중재자는 결합이 아예 없음. 하나의 클래스가 변경이 되어도 다른 클래스에 변겨이 없음. 커플링은 클래스 변경 시 참조한 다른 클래스도 수정해야 하는 것. 디커플링이 좋음
  8. 커맨드 패턴(Command Pattern) - 입력 시스템, 행동 기록 등에서 사용, 실행 취소/ 재실행 기능 구현에 유용 | 플레이어가 내린 명령을 최다적재 후 하나씩 꺼내 쓴다. 게임 내에서 동작을 커맨드로 쓰면 콤보공격과 같은 연속적인 공격 패턴을 사용하고 싶을 때, 공격 하나하나를 모두 커맨드 패턴으로 만들고 입력된 공격 2개(ex)를 묶어 발생되게함.
 
  9. SampleScene 이름을 Strategy로 변경
     Scenes
     scripts
     prefabs 파일 만들기
     package manager에서 input system 다운


     빌드 시 디버그 로그를 모두 제거해주아야 하는데, 전처리 기능을 이용
     #if 부터 #endif 안에 있는 코드는 빌드할 때 포함되지 않는다는 뜻.
     하지만 번거롭다! 부담스러워!
     그래서 사용할 수 있는 다른 방법은,


![image](https://github.com/user-attachments/assets/e8aa979f-d026-4ae7-9a45-c39504594a1a)
전역적으로 실행시킬 수 있음!
