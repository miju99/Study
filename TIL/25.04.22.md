## 25.04.22(화) TIL

#### 오늘 공부한 내용
* __생성자와 프로퍼티__
  * 생성자 : 객체가 처음 만들어질 때 어떤 값으로 시작할 지 정하는 곳
      1. 객체 내부 값 초기화
      2. 클래스와 이름이 동일해야 한다.
      3. 반환값이 없다.
      4. 게임 캐릭터를 만들 때, 처음 직업과 이름을 정하는 것.
         
  * 프로퍼티 : 그 객체가 가지고 있는 속성(정보)을 외부에서 읽거나 설정하는 창구
      1. 객체가 가진 속성이나 상태를 표현
      2. 다른 클래스 혹은 외부에서 값을 읽거나, 수정할 수 있도록 함.
      3. 게임 캐릭터 생성 후, 이름을 확인하거나 변경하는 창구
   
  * TryParse : 문자열을 숫자나 다른 데이터 타입으로 안전하게 변환할 때 유용
    
        bool 변수명 = 타입.TryParse(string, out 결과변수);
    
     - TryParse()의 첫 번째 인자는 반드시 string 타입이어야 함. => 문자열을 특정 타입으로 변환하기 위해 만드는 함수이므로
   
- #### 배열과 리스트
  - __배열(Array)__ - 원하는 만큼의 공간을 만들고 공간에 빠르게 접근하며 사용
    - 단점 : 배열을 넣거나 빼는 과정이 번거로움
   
  - __리스트 (List)__ - 배열보다 자유로운 구조, 데이터 추가 삭제가 쉬움
    - 다양한 데이터를 유동적으로 사용할 때 유용
    - 단점 : 내부적으로 배열을 사용함(동적 배열을 가지고 있음) 용량을 벗어났을 때 새로운 배열로 이전
   
    내용 | 배열 | 리스트
    |-|-|-|
    크기 | 고정|동적
    메모리 할당 | 연속적 할당 | 필요시 확장
    삽입/삭제|비효율적|유연
    데이터 접근 | 빠름|빠름
    적합한 상황 | 데이터 크기가 고정적|변동적

  <메모리 구조>
  * 배열
      - 주소는 항상 시작의 주소부터 시작한다.(여기서부터 저기까지 크기를 가정하고 시작하기 때문)
      - 그래서 인덱스는 0부터 시작. (첫 주소를 알고 있고, 주소의 첫 칸부터 시작하기 때문)
      - 데이터 한칸(시작점) 한 칸 이동 (그 다음) 식으로 표현한다.
  
  * 리스트
      - 내부적으로 배열을 사용. 주어진 크기를 넘어서면 새로운 배열을 할당. 기존 데이터를 복사해오는 과정에서 그만큼의 공간이동이 발생하기 때문에 무거워질 수 있음.<br>
      -> 해결하는 방법 : 아예 처음부터 공간을 많이 할당해놓으면 됨.
  
  <성능>
  * 배열 -> 크기 고정으로 삽입과 삭제 비효율적이지만, 인덱스를 통한 데이터 접근은 빠름
  * 리스트 -> 크기가 동적으로 변할 수 있어 삽입/삭제가  비교적 유연! 하지만 배열의 크기가 자동으로 확장되기 때문에 크기 확장 시 성능 저하 발생할 수 있음.
  
  * => 요새는 컴퓨터 성능이 좋기때문에 둘의 성능(속도)을 판단하기엔 미세한 차이로 느껴짐.
  
  <주요 메서드>
    * 배열
      - Length : 배열의 크기를 반환(길이 체크시 활용)
        - 메모리 할당이 이어져서 나오기 때문에 길이를 이어씀.
      - Array.Sort() : 배열을 오름차순으로 정렬
      - Array.Reverse() : 배열의 순서를 반전시킴 (내림차순의 정렬이 아님. 순서 반전만 해줌)
      - Array.Copy() : 배열을 다른 배열로 복사
        
    * 리스트
        - Add() : 리스트에 요소를 추가함.
        - Remove() : 리스트에서 특정 요소를 제거함. 값을 줘야함. 값과 동일한 애를 찾음. 똑같은 애가 여러개면 먼저 발견한 애를 제거
        - Sort() : 리스트를 오름차순 정렬
        - Inser() : 리스트의 특정 위치에 요소 삽입
        - Count : 리스트에 포함된 요소의 개수 반환
         - 비선형의 구조를 가지기 때문에 (메모리가 어디있는 지 모르기때문에) Count를 사용
   
  <성능 최적화 기법>
    * 배열 확장
        - 배열은 고정된 크기로 선언되기 대문에 크기를 늘리려면 배열을 새로 생성 후 기존 데이터를 복사해야 함. (Array.copy 사용)
    * 리스트의 초기 용량 설정
        - List<int> myList = new List<int>(100);
  
  <반복문>
    * for문 : 인덱스 기반 접근으로 빠름 -> 직접적으로 바꿔줘야 할 때 사용
        - 직접적으로 숫자를 만들어 내 직관적임.
    * foreach문 : 코드 가독성은 높지만 내부적으로 반복자(iterator)를 사용하여 성능이 조금 느릴 수 있음. -> 전체적인 순환만 필요할 때 사용
        - foreach(int num in numbrs)인 경우, numbers를 꺼내 num에 넣어 사용
        - numbers를 꺼내오는 경우 실제 자료구조에 접근하는 게 아니라 자료구조의 값을 하나씩 꺼내와 복사해 사용함.
    
  <적절한 사용 시점>
    * 배열
      - 데이터 크기가 고정적일 때
      - 성능 최적화가 중요한 경우
     
    * 리스트
      - 동적으로 크기가 변한느 데이터를 다룰 때
      - 데이터 추가 및 삭제가 빈번한 경우
  
  <추가 내용>
  내가 만든 용량보다 덜 쓸 때 리스트를 정리하고 싶으면, list.TrimExcess()
