## 25.04.14(월) TIL

### 1. 문제 1번

#### 2. 시도
#### 3. 해결
#### 4. 알게된 점

#### 알게된 점이나 복습한 내용
- __switch case문에서 else와 같은 기능 - default__
  
       ex)
         case 0:
         case 1 :
             Console.WriteLine("1");
             break;
           case 2 :
             Console.WriteLine("2");
             break;
           default : //생략가능
             Console.WriteLine("Error");
             break;
  
- __break point__ <br>
  단축키 F9 || 줄 번호 왼쪽 라인 클릭(빨간 점이 생김)
  > : 코드르 실행하지 않고 멈춰있겠다. <br>
  > * F10을 누르면 한 칸 한 칸 이동 (넘어감)
  > * F11을 누르면 해당 코드를 파고 들어가서 봄
  >> 디버깅 창 설정) 디버그 -> 창 -> 조사식, 자동, 호출스택, 등..
<br>

- __3항 연산자__ <br>
  if문 형태, 조건식의 결과에 따라 두 값을 선택 => if else와 같은 결과
  
       ex) (조건식) ? 참일 경우 값 : 거짓일 경우 값;
         int currentFull = 1000;
         int maxFull = 1500;
         
         string result = (currentFull <= maxFull) ? "섭취 가능" : "섭취 불가능";
         > 현재 포만도가 최대 포만도보다 작으므로 "섭취 가능이 나온다."
<br>
  
- __문자열 처리 기능__
  - 문자열 생성
       
         string str = new string('A', 10);
  - 문자열 연결

  - 문자열 분할 (Split)
    
        string str = "Hello, World!";
        string[] words = str.Split(',');
        // words[0] == Hello
        // words[1] ==  World!

  - 문자열 검색 (IndexOf)
 
        string str = "Hello, World!";
        int index = str.indexOf("World");
        //H부터 0으로 시작해서 H/e/l/l/o/,/ /W이 7번째 시작하므로 7이 나온다.

  - 문자열 대체 (Replace)
 
        string str = "Hello, World!";
        string newStr = str.Replace("World", "Universe");
        //newStr은 Hello, Universe!, str은 Hello, World!로 나온다.

  - 문자열 비교 (대소 비교 - Compare)

        string str1 = "ABC";
        strign str2 = "CDF";

        int compare = string.Compare(str1, str2);
        //compare을 출력하면 -1이 나온다.

  - 문자열 포맷팅
        - 문자열 형식화

         int a = 1;
         int b = 2;
         string message = string.foramt("a {a} b { b}", a, b);
         //message를 출력하면 a 1 b 2 가 나온다.

        - 문자열 보간
    
         string message = $"a {a} b {b}";
         //message를 출력하면 a 1 b 2 가 나온다.

- __foreach__
  
       string[] chocolateC = {"ABC", "Ghana", "Hershey's"};
       foreach(string chocolateN in chocolateC)
         {
         Console.WriteLine(chocolateN);
         }

- __continue와 break의 차이__
  - continue -> 이번 회차만 건너감 (다시 증감부터 시작)
  - break -> 반복문을 떠남
  
- __비쥬얼 스튜디오 단축키__
  > - 들여쓰기) Ctrl + K + F
  > - 주석) Ctrl + K + C
  > - 주석 해제) Ctrl + K + U
  > - 자동 완성 Intellisense 호출) Ctrl + Space
  > - 코드 조각 샘플) Tab + Tab
  > - 자동 완성) Tab

- __클래스__
  
       class Person
       {
           public string Name;
           ...
       }
       
       Person p = new Person();
       p.Name = "John";
  > - 클래스는 레퍼런스 타입 <br>
  > - Person p는 실제로 공간이 생긴 것이 아닌, 주소를 저장할 수 있는 p만 있는 것. <br>
  > - new Person을 통해 공간을 만들고, 그 주소를 p에 연결 <br>


- __get & set__ -> 프로퍼티
  
       [접근 제한자] [데이터 타입] 프로퍼티명
       {
           get
           {
               //필드 반환 & 다른 로직 수행
           }
           set
           {
               필드에 값 설정 & 다른 로직 수행
           }
       }
<br>

       class Person
       {
          private string name; //외부에서 접근 불가능
  
          public string Name;
          {
             get
             { return name;}
             set
             { name = value;}
          }
       }

      Person person = new Person();

      person.Name = "Ami";
      
      Console.WriteLine($"Name: {person.Name}");

> - Person에서 name을 private로 선언했기 때문에 외부에서 접근이 불가능함.
>   <br><br>
> - 그래서 string에 Name을 만들어 주고,
> - Name을 get(가져다 쓰겠다) => person.Name 하면
> - get이 name을 return 해준다. 그래서 소문자 name의 값이 person.Name에 들어감.
>   <br><br>
> - 반대로, person.Name에 Ami를 할당해주면, 넘어온 값(Ami)가 name = value의 value로 들어가게 됨.
> - 그래서 name에 value를 세팅해줄 수 있음.

       public string Name
       {
           get {return name;}
           private set {name = value; }
       }
      
> - private로 set을 막아준 것.
> - public으로 프로퍼티를 만들었지만(string Name) set자체를 private로 막아줌.
> - 프로퍼티 자체는 외부에서 접근 가능하지만 세팅은 무조건 이 클래스 내부에서 하겠다고 제한을 둠
> - 결국 get으로 값을 가져가는 것만 가능(외부에서 이름을 가져가는 것만 가능하고 세팅은 내부에서만 가능)
