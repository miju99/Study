## 25.05.18(ìˆ˜) TIL

### ì˜¤ëŠ˜ í•œ ì¼
íŒ€í”Œ

### ë³´ì™„í•´ì•¼ í•  ì 
1. ì „ë¶€ ë‹¤

### ìµœì¢… ì½”ë“œ

<details>
  <summary>[GhostCollder.cs]</summary>

  ```csharp
using System.Collections;
using UnityEngine;

public class GhostCollider : MonoBehaviour
{
    /// <summary>
    /// ìì‹ ì˜¤ë¸Œì íŠ¸ì˜ Transform
    /// </summary>
    public Transform ghostColliderTransform;
    /// <summary>
    /// ì ì˜ ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€
    /// </summary>
    public Sprite ghostSprite;
    /// <summary>
    /// í”Œë ˆì´ì–´ê°€ ì„ íƒí•´ì•¼ í•  ìœ„ì¹˜ë¥¼ ì•Œë ¤ì£¼ëŠ” ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€
    /// </summary>
    public Sprite circleColliderSprite;

    private CircleCollider2D circleCollider; //ê¸°ì¦ˆëª¨

    /// <summary>
    /// Colliderê°€ ì´ë™í•  ê³ ì • ìœ„ì¹˜ë¥¼ ì €ì¥í•  ë°°ì—´
    /// </summary>
    private Vector3[] fixedPositions;
    /// <summary>
    /// Colliderì˜ ì´ë™ ì£¼ê¸°
    /// </summary>
    private float moveInteval = 5f;

    private void Start()
    {
        if(ghostColliderTransform == null)
        {
            Logger.Log("Ghostì˜ ìœ„ì¹˜ ì•Œ ìˆ˜ ì—†ìŒ.");
            return;
        }

        GenerateRandomPositions(3); //ëœë¤ ìœ„ì¹˜ ìƒì„±
        StartCoroutine(MoveCollider()); //Collider ìœ„ì¹˜ êµì²´
    }

    /// <summary>
    /// ì¼ì • ì‹œê°„ë§ˆë‹¤ Colliderê°€ ì´ë™í•˜ëŠ” ì½”ë£¨í‹´
    /// </summary>
    /// <returns></returns>
    IEnumerator MoveCollider()
    {
        while (true)
        {
            yield return new WaitForSeconds(moveInteval); //moveIntevalë§Œí¼ ëŒ€ê¸°

            int randomIndex = Random.Range(0, fixedPositions.Length); //3ê°œì˜ ê³ ì • ìœ„ì¹˜ ì¤‘ í•˜ë‚˜ë¥¼ ëœë¤ ì„ íƒ
            //ghostColliderTransform.localPosition = fixedPositions[randomIndex]; //ghostColliderTransformì˜ ìœ„ì¹˜ ê°±ì‹ 
            //ghostColliderTransform.localPosition += new Vector3(0, -1.5f, 0);
            Vector3 worldTarget = fixedPositions[randomIndex] + new Vector3(0, -1.5f, 0);
            ghostColliderTransform.localPosition = transform.InverseTransformPoint(worldTarget);

            Logger.Log($"ê³ ìŠ¤íŠ¸ ë¡œì»¬ ìœ„ì¹˜: {ghostColliderTransform.localPosition}");
            Logger.Log($"ê³ ìŠ¤íŠ¸ ì›”ë“œ ìœ„ì¹˜: {ghostColliderTransform.position}");
        }
    }

    /// <summary>
    /// ëœë¤ìœ¼ë¡œ Colliderì˜ ìœ„ì¹˜ 3ê³³ì„ ì§€ì •í•˜ëŠ” ë©”ì„œë“œ
    /// </summary>
    /// <param name="count"></param>
    void GenerateRandomPositions(int count)
    {
        fixedPositions = new Vector3[count]; //ìœ„ì¹˜ ë°°ì—´ ì´ˆê¸°í™”    
        Bounds bounds = ghostSprite.bounds; //ìŠ¤í”„ë¼ì´íŠ¸ì˜ í¬ê¸° ë° ìœ„ì¹˜ ì •ë³´

        Logger.Log((bounds.size.x / 2).ToString());
       
        float minDistance = 1f; //ìœ„ì¹˜ë“¤ê°„ì˜ ìµœì†Œ ê±°ë¦¬
        int maxAttempts = 30; //ìµœëŒ€ ì¬ì‹œë„ íšŒìˆ˜

        for (int i = 0; i < count; ++i) //ì›í•˜ëŠ” ìœ„ì¹˜ ê°œìˆ˜ë§Œí¼ ë°˜ë³µ
        {
            Vector3 newPos; //ìƒì„±ëœ ìœ„ì¹˜ ì €ì¥í•  ë³€ìˆ˜
            int attempts = 0; //ì‹œë„ íšŸìˆ˜ ì €ì¥í•  ë³€ìˆ˜

            do
            {
                float x = Random.Range(bounds.min.x + circleColliderSprite.bounds.size.x /2f, bounds.max.x - circleColliderSprite.bounds.size.x / 2f);
                float y = Random.Range(bounds.min.y + circleColliderSprite.bounds.size.y / 2f, bounds.max.y - circleColliderSprite.bounds.size.y / 2f);
                newPos = new Vector3(x, y, 0); //ë¬´ì‘ìœ„ ìœ„ì¹˜ ìƒì„±

                attempts++; //ì‹œë„ íšŸìˆ˜ ì¹´ìš´íŠ¸

                if(attempts > maxAttempts) //ìµœëŒ€ íšŸìˆ˜ë¥¼ ë„˜ê¸°ë©´ ì¤‘ë‹¨
                {
                    break;
                }

            } while (!IsFarEnough(newPos, i, minDistance) || !IsOpaque(newPos)); //ìƒˆë¡œìš´ ìƒì„± ìœ„ì¹˜ê°€ minDistanceë³´ë‹¤ ê°€ê¹Œìš°ë©´ ë°˜ë³µ -> ìƒˆ ìœ„ì¹˜ê°€ ê¸°ì¡´ ìœ„ì¹˜ë“¤ê³¼ ì¶©ë¶„íˆ ë–¨ì–´ì ¸ ìˆì§€ ì•Šìœ¼ë©´ ê³„ì† ë°˜ë³µ

            fixedPositions[i] = newPos; //ì¡°ê±´ì— ë§ê±°ë‚˜, ë§ˆì§€ë§‰ ìœ„ì¹˜ ì €ì¥
        }
    }

    bool IsFarEnough(Vector3 pos, int currentIndex, float minDist) //í˜„ì¬ ìƒì„± ìœ„ì¹˜ê°€ ê¸°ì¡´ ìœ„ì¹˜ì™€ ë–¨ì–´ì ¸ìˆëŠ” ì§€ ê²€ì‚¬
    {
        for(int i = 0; i < currentIndex; ++i)
        {
            if(Vector3.Distance(pos, fixedPositions[i]) < minDist) //ì •í•´ì§„ ìµœì†Œ ê±°ë¦¬ë³´ë‹¤ ê°€ê¹Œìš¸ ë•Œ
            {
                return false;
            }
        }
        return true;
    }

    private void OnDrawGizmos() //Collider ê¸°ì¦ˆëª¨
    {
        if (circleCollider == null)
        {
            circleCollider = GetComponent<CircleCollider2D>();
        }

        if(circleCollider != null)
        {
            Gizmos.color = Color.red;
            Vector3 center = transform.position + (Vector3)circleCollider.offset;
            float radius = circleCollider.radius * Mathf.Max(transform.lossyScale.x, transform.lossyScale.y);
            Gizmos.DrawWireSphere(center, radius);
        }
    }

    bool IsOpaque(Vector3 worldPos) //ì´ë¯¸ì§€ì˜ íˆ¬ëª… ë¶€ë¶„(ì•ŒíŒŒê°’ ë¹„êµ)ì— Colliderê°€ ë“¤ì–´ê°€ì§€ ì•Šë„ë¡
    {
        Vector3 localPos = ghostColliderTransform.InverseTransformPoint(worldPos);
        Bounds bounds = ghostSprite.bounds;

        float normalizedX = (localPos.x - bounds.min.x) / bounds.size.x;
        float normalizedY = (localPos.y - bounds.min.y) / bounds.size.y;

        if(normalizedX < 0 || normalizedX > 1 || normalizedY < 0|| normalizedY > 1)
        {
            return false;
        }

        Rect spriteRext = ghostSprite.rect;
        Texture2D texture = ghostSprite.texture;

        int pixelX = Mathf.FloorToInt(spriteRext.x + spriteRext.width * normalizedX);
        int pixely = Mathf.FloorToInt(spriteRext.y + spriteRext.height * normalizedY);

        Color color = texture.GetPixel(pixelX, pixely);
        return color.a > 0.1f;
    }
}

```
</details>

<details>
  <summary>[AutoAttack.cs]</summary>

  ```csharp
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class AutoAttack : MonoBehaviour
{
    private float attackInterval; //ìë™ ê³µê²© ì£¼ê¸°
    private bool isAutoAttacking = false; //ê³µê²© ì¤‘ì¸ì§€ í™•ì¸

    [SerializeField]
    private GameObject attackEffectPrefab; //ì´í™íŠ¸ í”„ë¦¬íŒ¹
    [SerializeField]
    private GameObject criticalAttackEffectPrefab; //í¬ë¦¬í‹°ì»¬ ì´í™íŠ¸ í”„ë¦¬íŒ¹

    /// <summary>
    /// í¬ë¦¬í‹°ì»¬ í™•ë¥  (í›„ì— ê²Œì„ë§¤ë‹ˆì €ì—ì„œ ìµœì¢… ì¹˜ëª…íƒ€ í™•ë¥  ë°›ì•„ì˜¤ê¸°)
    /// </summary>
    private float criticalChance = 0.2f;
    private float criticalDamage = 5f; //ì¹˜ëª…íƒ€ ë°ë¯¸ì§€
    private float damage = 1f; //ê³µê²©ë ¥

    private Coroutine autoAttackCoroutine; //ì½”ë£¨í‹´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€

    private Transform targetImage; //ê³µê²©í•  ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì´ë¯¸ì§€
    private GameObject enemy; //ì  ì˜¤ë¸Œì íŠ¸

    private int effectPoolSize = 10; //í’€ ì‚¬ì´ì¦ˆ
    private List<GameObject> effectPool = new List<GameObject>(); //ì´í™íŠ¸ ì €ì¥ í’€
    private List<GameObject> criticalEffectPool = new List<GameObject>(); //í¬ë¦¬í‹°ì»¬ ì´í™íŠ¸ ì €ì¥ í’€

    [SerializeField]
    private Transform effectPoolParent;

    [SerializeField]
    private PlayerStatus playerStatus;

    [SerializeField]
    private TextMeshProUGUI on;
    [SerializeField]
    private TextMeshProUGUI off;

    public void Start()
    {

        off.gameObject.SetActive(false);
        Logger.Log($"attackEffectFrefab is {(attackEffectPrefab == null ? "null" : "not null")}");
        Logger.Log($"criticalAttackEffectFrefab is {(criticalAttackEffectPrefab == null ? "null" : "not null")}");

        criticalChance = GameManager.Instance.weaponStats.critChance;
        criticalDamage = GameManager.Instance.weaponStats.critMultiplier;
        damage = GameManager.Instance.weaponStats.baseDamage;

        //attackInterval = playerStatus.autoClickPerSecond;
        attackInterval = 1f/playerStatus.autoClickPerSecond;

        enemy = GameObject.FindWithTag("Enemy");

        if (enemy != null)
        {
            Logger.Log("Enemy ì˜¤ë¸Œì íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.");
            targetImage = enemy.transform.Find("Collider");
        }
        else
        {
            Logger.Log("Enemy Tagë¥¼ ê°€ì§„ ì˜¤ë¸Œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
        }

        for (int i = 0; i < effectPoolSize; i++) //í’€ ì±„ìš°ê¸° (ì´í™íŠ¸ ì˜¤ë¸Œì íŠ¸ ìƒì„±)
        {
            GameObject obj = Instantiate(attackEffectPrefab); //ì´í™íŠ¸ í”„ë¦¬íŒ¹ ìƒì„±
            obj.SetActive(false); //ë¹„í™œì„±í™” í›„ ë³´ê´€
            effectPool.Add(obj); //í’€ì— ì¶”ê°€

            GameObject critical = Instantiate(criticalAttackEffectPrefab);
            critical.SetActive(false);
            criticalEffectPool.Add(critical);
        }
    }

    /*public void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space)) //ìŠ¤í˜ì´ìŠ¤ í‚¤ë¥¼ ëˆ„ë¥´ë©´
        {
            this.StartAutoAttack(); //ìë™ ê³µê²© ì‹œì‘
        }
        if (Input.GetKeyDown(KeyCode.P)) //Pí‚¤ë¥¼ ëˆ„ë¥´ë©´
        {
            this.StopAutoAttack(); //ìë™ ê³µê²© ì¤‘ë‹¨
            targetImage.gameObject.SetActive(true); //ìœ„ì¹˜ ì´ë¯¸ì§€ í™œì„±í™”
        }
    }*/

    private void Update()
    {
        if (isAutoAttacking && (enemy == null || !enemy.activeInHierarchy))
        {
            GameObject newEnemy = GameObject.FindWithTag("Enemy");
            if (newEnemy != null)
            {
                enemy = newEnemy;
                targetImage = enemy.transform.Find("Collider");
                Logger.Log("ìƒˆë¡œìš´ ì  ë°œê²¬ ë° ìë™ ê³µê²© ì‹œì‘");
            }
        }
    }

    public void OnClickButton()
    {
        Logger.Log("ë²„íŠ¼ì„ ëˆŒë €ìŠµë‹ˆë‹¤");
        if (isAutoAttacking)
        {
            Logger.Log("ìë™ ê³µê²© ì¢…ë£Œ");
            StopAutoAttack(); //ìë™ ê³µê²© ì¤‘ë‹¨
            if (targetImage != null)
            {
                targetImage.gameObject.SetActive(true); //ìœ„ì¹˜ ì´ë¯¸ì§€ í™œì„±í™”
                on.gameObject.SetActive(true);
                off.gameObject.SetActive(false);
            }
            else
            {
                Logger.Log("Warning : targetImage == null");
            }
        }
        else
        {
            Logger.Log("ìë™ ê³µê²© ì‹œì‘");
            StartAutoAttack(); //ìë™ ê³µê²© ì‹œì‘
            on.gameObject.SetActive(false);
            off.gameObject.SetActive(true);
        }
    }

    /// <summary>
    /// ìë™ ê³µê²© ì‹œì‘
    /// </summary>
    public void StartAutoAttack()
    {
        Logger.Log("StartAutoAttack í˜¸ì¶œ");
        if (!isAutoAttacking) //ê³µê²© ì¤‘ì´ ì•„ë‹ˆë©´
        {
            isAutoAttacking = true;
            autoAttackCoroutine = StartCoroutine(AutoAttackRoutine());
        }
    }

    /// <summary>
    /// ìë™ ê³µê²© ì¤‘ë‹¨
    /// </summary>
    public void StopAutoAttack()
    {
        if (isAutoAttacking) //ê³µê²© ì¤‘ì´ë©´
        {
            isAutoAttacking = false;
            if (autoAttackCoroutine != null)
            {
                StopCoroutine(autoAttackCoroutine); //ì½”ë£¨í‹´ ì •ì§€
                autoAttackCoroutine = null; //ì°¸ì¡° ì œê±°
            }
        }
    }

    /// <summary>
    /// ì¼ì • ì‹œê°„ë§ˆë‹¤ ì´í™íŠ¸ ì¬ìƒ
    /// </summary>
    /// <returns></returns>
    public IEnumerator AutoAttackRoutine()
    {
        while (isAutoAttacking) //ê³µê²© ì¤‘ì¼ ë•Œë§Œ ë°˜ë³µ
        {
            if (enemy != null)
            {
                bool isCritical = Random.value < criticalChance;

                //Instantiate(attackEffectFrefab, enemy.transform.position, Quaternion.identity);
                GameObject effect = GetEffectFromPool(
                    isCritical ? criticalEffectPool : effectPool,
                    isCritical ? criticalAttackEffectPrefab : attackEffectPrefab); //í’€ì—ì„œ ì´í™íŠ¸ë¥¼ êº¼ë‚´ì„œ
                effect.transform.position = enemy.transform.position; //ì  ìœ„ì¹˜ì— ë°°ì¹˜
                effect.SetActive(true); //í™œì„±í™”

                float dm = isCritical ? criticalDamage : damage;
                Logger.Log(dm.ToString());

                // ğŸŸ¢ ìˆ˜ì •: ì£¼ì„ì„ ì‹¤ì œ ì½”ë“œë¡œ ë³€ê²½
                //ì  ì²´ë ¥ì„ dmë§Œí¼ ê°ì†Œ
                EnemyHealth enemyHealth = enemy.GetComponent<EnemyHealth>();
                if (enemyHealth != null) enemyHealth.TakeDamage(dm);

                Logger.Log("ì ì˜ HP : " + enemyHealth.CurrentHealth);

                //ì¬í™” ë“¤ì–´ì˜¤ëŠ” ê³³
                playerStatus.gold += playerStatus.goldPerClick;
                Logger.Log("í”Œë ˆì´ì–´ ì¬í™” : " + GameManager.Instance.playerStats.gold.ToString());
                Logger.Log("ê³µê²© ì£¼ê¸°:" + attackInterval);

                ParticleSystem ps = effect.GetComponent<ParticleSystem>();

                if (ps != null)
                {
                    ps.Play();
                    float duration = ps.main.duration + ps.main.startLifetime.constantMax; //íŒŒí‹°í´ ì¬ìƒ ì‹œê°„
                    StartCoroutine(ReturnEffectToPool(effect, duration)); //ì¬ìƒ ì‹œê°„ í›„ ë¹„í™œì„±í™”
                }

                if (targetImage != null)
                {
                    targetImage.gameObject.SetActive(false);//ìœ„ì¹˜ ì´ë¯¸ì§€ ë¹„í™œì„±í™”
                }
                Logger.Log($"ìë™ ê³µê²© ì‹œì‘");
            }
            yield return new WaitForSeconds(attackInterval); //ê³µê²© ì£¼ê¸° ì„¤ì •
        }
    }

    private GameObject GetEffectFromPool(List<GameObject> pool, GameObject prefab)
    {
        foreach (GameObject obj in pool) //í”Œì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´
        {
            if (!obj.activeInHierarchy) //ë¹„í™œì„±í™”ëœ ì˜¤ë¸Œì íŠ¸ ì¡´ì¬ ì‹œ
            {
                return obj; //ì˜¤ë¸Œì íŠ¸ ì‚¬ìš©
            }
        }

        GameObject newObj = Instantiate(prefab); //í’€ì— ì´í™íŠ¸ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ë§Œë“¦.
        newObj.SetActive(false);
        pool.Add(newObj); //ì¶”ê°€
        return newObj;
    }

    private IEnumerator ReturnEffectToPool(GameObject effect, float delay)
    {
        yield return new WaitForSeconds(delay);
        effect.SetActive(false);
    }
}
```
</details>

<details>
  <summary>[TouchAttack.cs]</summary>

  ```csharp
using UnityEngine;
using UnityEngine.EventSystems;

public class TouchAttack : MonoBehaviour
{
    /// <summary>
    /// Attack ì‹œ ì‚¬ìš©í•  íŒŒí‹°í´
    /// </summary>
    [SerializeField]
    private GameObject attackEffectPrefab;
    /// <summary>
    /// Attack ì‹œ ì‚¬ìš©í•  í¬ë¦¬í‹°ì»¬ íŒŒí‹°í´
    /// </summary>
    [SerializeField]
    private GameObject criticalAttackEffectPrefab;

    private float criticalChance; //ì¹˜ëª…íƒ€ í™•ë¥ 
    private float criticalDamage; //ì¹˜ëª…íƒ€ ë°ë¯¸ì§€
    private float damage; //ê³µê²©ë ¥
    
    public PlayerStatus playerStatus;

    private void Start()
    {
        criticalChance = GameManager.Instance.weaponStats.critChance;
        criticalDamage = GameManager.Instance.weaponStats.critMultiplier;
        damage = GameManager.Instance.weaponStats.baseDamage;
    }
    private void Update()
    {
        if (Input.GetMouseButtonDown(0) && !AnyTouchOnUI() && !EventSystem.current.IsPointerOverGameObject())
        {
            Vector2 touchPosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            //í´ë¦­í•œ ìŠ¤í¬ë¦° ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜ (ì›”ë“œ ì˜¤ë¸Œì íŠ¸ë¥¼ í´ë¦­í–ˆì„ ë•Œ ìœ„ì¹˜ í™•ì¸)

            Collider2D hitcollider = Physics2D.OverlapPoint(touchPosition); //collider2Dê°€ ìˆëŠ” ì§€ ê²€ì‚¬

            if (hitcollider != null) //colliderê°€ ìˆìœ¼ë©´
            {
                GameObject hitobject = hitcollider.gameObject; //colliderê°€ ë¶™ì–´ìˆëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ì ¸ì˜´.

                bool isCritical = Random.value < criticalChance; //í¬ë¦¬í‹°ì»¬ ê³µê²©ì„ í•˜ê¸° ìœ„í•œ í™•ë¥  ê³„ì‚°

                GameObject effectPrefab = isCritical ? criticalAttackEffectPrefab : attackEffectPrefab; //í¬ë¦¬í‹°ì»¬ ì—¬ë¶€ì— ë”°ë¥¸ ì´í™íŠ¸ ì„ íƒ
                GameObject effect = Instantiate(effectPrefab, touchPosition, Quaternion.identity); //í´ë¦­ ìœ„ì¹˜ì— ì´í™íŠ¸ ìƒì„±

                ParticleSystem ps = effect.GetComponent<ParticleSystem>(); //ì´í™íŠ¸ ì˜¤í”„ì íŠ¸ì— íŒŒí‹°í´ ì‹œìŠ¤í…œì„ ì €ì¥

                if (ps != null) //ì´í™íŠ¸ê°€ ìˆë‹¤ë©´
                {
                    ps.Play(); //ì‹¤í–‰
                    Destroy(effect, ps.main.duration + ps.main.startLifetime.constantMax); //íŒŒí‹°í´ ì¬ìƒ ì§€ì† ì‹œê°„ + íŒŒí‹°í´ì´ ì‚´ì•„ìˆëŠ” ì‹œê°„          
                }

                Logger.Log($"{hitobject.name} < hitobjectì˜ ì´ë¦„");

                if (hitobject.name == "Collider")
                {
                    float dm = isCritical ? criticalDamage : damage;

                    // ğŸŸ¢ ìˆ˜ì •: ì£¼ì„ì„ ì‹¤ì œ ì½”ë“œë¡œ ë³€ê²½
                    //ì  ì²´ë ¥ì„ dmë§Œí¼ ê°ì†Œ
                    EnemyHealth enemyHealth = hitobject.GetComponentInParent<EnemyHealth>();
                    if (enemyHealth != null) enemyHealth.TakeDamage(dm);

                    Logger.Log(dm.ToString());
                    Logger.Log($"{hitobject.name}ë¥¼ {(isCritical ? "í¬ë¦¬í‹°ì»¬!" : "ê³µê²©!")}");

                    playerStatus.gold += playerStatus.goldPerClick;
                }
            }
        }
    }

    bool AnyTouchOnUI()
    {
        for (int i = 0; i < Input.touchCount; i++)
        {
            if (EventSystem.current.IsPointerOverGameObject(Input.GetTouch(i).fingerId))
            {
                return true;
            }
        }
        return false;
    }
}
```
</details>

<details>
  <summary>[Image]</summary>

  ![Zombie_8](https://github.com/user-attachments/assets/d668d7d5-97db-4dcc-8dd2-0a8337633254)
  
 ![WaterGhost](https://github.com/user-attachments/assets/2b6c32da-683c-4493-9456-035da4400edd)

 ![Ghost](https://github.com/user-attachments/assets/f4869511-00c4-42bd-8f4b-794c3be3d4a3)


</details>
