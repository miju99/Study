## 2025.04.16(수) TIL
### 오늘 공부한 내용

#### 인터페이스
1. 다중상속을 사용하지 않는 이유
     1. 여러 부모클래스로부터 동일한 멤버를 상속받음으로써 코드가 복잡해지고 가독성이 저하됨
     2. 클래스간의 관계가 복잡해짐
     3. 여러 부모클래스로부터 상속받은 멤버들의 이름 충돌
     4. 설계의 일관성과 단순성을 유지하기 위해
2. 인터페이스 사용 이유
     1. 동일한 기능을 공유함으로써 코드를 재사용
     2. 다중 상속 지원
     3. 클래스와 인터페이스간의 느슨한 결합 형성 > //////////////////////////////////////////////여기 쓰는 중!

#### 열거형(enum)
- 가독성이 좋아진다.
- ↘ 의미 있는 이름을 사용하여 상수를 명명함으로써 상수의 의미를 명확히 설명할 수 있다.
- ↘ 스위치 문과 호환성이 좋다.

[열거형 정의]

    enum (enum타입을 정의한 이름)
    {
    열거형 상수
    }
예시 ↓

    enum Family
    {
      Father,
      Mother,
      Sister,
      Brother
     }
  
     자동으로 Father 의 값 == 0, 이후 1씩 더해져 Mother == 1, Sister == 2....가 된다.
   <br>

[열거형 상수 값 지정]

    enum Family
    {
      Father = 10,
      Mother,
      Sister = 30,
      Brother
    }

    Father의 값이 10이면 그 다음 순서인 Mother의 값은 +1이 된 11이 되고,
    Sister의 값이 30이면 그 다음 순서인 Brother의 값은 +1이 된 31이 된다.

  [출력]
  
    public enum Month
    {
        Janu = 1,
        Feb,
        Mar,
        Apr,
        May,
        Jun,
        Jul,
        Aug,
        Sep,
        Oct,
        Nov,
        Decr
    }
    
    // 처리하는 함수
    static void ProcessMonth(int month)
    {
        if (month >= (int)Month.January && month <= (int)Month.December)
        {
            Month selectedMonth = (Month)month;
            Console.WriteLine("선택한 월은 {0}입니다.", selectedMonth); <<문자열 포맷팅
        }
        else
        {
            Console.WriteLine("올바른 월을 입력해주세요.");
        }
    }
    
    static void Main()
    {
        int userInput = 7; //임의로 지정한 유저 입력값
        ProcessMonth(userInput);
    }

Month는 enum타입이므로 month의 자료형인 int에 맞추기 위해 __형 변환__ 을 해야한다.
    
+ 문자열 포맷팅
  - {0}은 자리 표시자로, selectedMonth의 값이 {0} 위치에 들어가게 된다.
  - 인수 순서대로 값을 넣는다.
  - = string.Format

+ (+) 문자열 보간법
  - 더 직관적이고 간결하게 표현할 수 있다.
  - 메서드 호출을 넣거나, 연산이 가능하다. (표현식 사용 가능)
    
        Console.WriteLine($"선택한 월은 {selectedMonth}입니다.");

+ 포맷팅과 보간법의 차이
    - 포맷팅 : 숫자 형식 지정이나 복잡한 포맷에 유용
    - 보간법 : 직접 변수 삽입/표현식 사용이 가능하여 간결하고 직관적

#### 값 형식 vs 참조 형식
값 형
- 변수에 값을 직접 저장
- 값이 복사
- int, float. double. bool 등의 기본 데이터 타입들이 값형에 해당
  
<이 외 값형식인 것들>
- enum
- struct

참조형
- 참조(메모리주소)를 저장
- 참조가 복사
- 클래스, 배열, 인터페이스 등이 참조형에 해당

  <클래스 예시>
  
      class Person
      {
          public string Name;
      }
      
      Person p1 = new Person();
      p1.Name = "Alice";
      
      Person p2 = p1;    // p2는 p1과 같은 객체를 가리킴
      p2.Name = "Bob";   // 같은 객체의 Name을 바꿈

      Console.WriteLine(p1.Name);
  
  <시각화 설명>
  
        Heap (힙 메모리)
      ┌──────────────────────┐
      │  Person 객체         │
      │  Name: "Alice"       │
      └──────────────────────┘
            ▲         ▲
            │         │
           p1        p2  ← 둘 다 같은 객체를 참조

  > p2가 p1의 주소를 복사하는 행동(Person p2 = p1;)을 함으로써   
  > p1고 p2가 동일한 객체(Person)을 나타내고 있고,   
  > p2의 값이 바뀌면 결국 Person의 내용이 변경됨으로써   
  > p1의 값도 같이 바뀌게 되는 것이다.

  <details>
    <summary>[p2가 p1의 참조가 아닐 때]</summary>
    
      Person p1 = new Person();
      p1.Name = "Alice";
      
      Person p2 = new Person(); // 완전 새로운 객체
      p2.Name = "Bob";
      
      Console.WriteLine(p1.Name); // 결과값 : Alice
      Console.WriteLine(p2.Name); // 결과값 : Bob
  </details>

<이 외 참조형식인 것들>
- string [불변타입]
- 컬렉션 타입(List<T>, Dictionary<TKey,TValue>,HashSet<T>)

  <string 예시>
  
      string s1 = "hello";
      string s2 = s1; //동일한 "hello"를 가리킨다. > s2에 복사할 때는 새로운 객체가 만들어지게 됨.
      s2 = "world"; //s2가 "world"를 가리키게 된다. > 새로운 문자열 객체를 생성하고 새 객체를 가리키게 됨.
      
      Console.WriteLine(s1); // "hello"
      Console.WriteLine(s2); // "world"
      > s1과 s2는 완전히 독립적 객체가 된다.
      > 위 코드에서 (line2)string s2 = s1;는 삭제되어도 결과는 똑같이 나온다.


#### 새로 알게 된 사실
여러 줄 주석 단축키 Ctrl + Shift + /
